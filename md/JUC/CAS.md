## CAS

### CAS 原理

CAS （compare and swap）算法包含三个参数，分别是当前内存值 V，旧的预期值 A，要写入的新值。当且仅当 V 的值等于 A 时，CAS 才会通过原子方式用新的值 B 来更新该内存位置的值，否则不进行任何操作。

CAS 是乐观锁的一种，如果在执行 CAS 的时候发现变量的值已经被修改过了，那么不能简单地继续进行后续更新操作，因为在此之前读到的数据已经是脏数据了。当多个线程使用 CAS 的方法同时更新一个变量时，只有其中一个线程能更新成功，其他线程都将失败。

**例如：**

线程 A 和线程 B 同时对变量 m = 1 执行加 1 的操作，正常情况下希望得到的最终结果是 m = 3（加了两次）。如果不使用 CAS，可能发生的一种情况是：第一阶段两个线程同时取到 m 的值，ma = 1 且 mb = 1（Java 内存模型中，各线程工作内存中分别持有变量副本）。第二阶段两个线程分别对 ma 和 mb 进行更新，此时 ma = 2 且 mb = 2。第三阶段，线程 a 首先将 ma = 2 写入主内存，m = 2，然后线程 b 将 mb = 2 写入主内存，m 的值还是 2。与预期结果不符。

使用 CAS 方式，在线程 b 写入时，首先检查 V 和 A 是否相等，此时 V = 2，而预期的 A = 1，V 不等于 A，不允许写入。

### CAS 的三个缺陷

**ABA 问题**

如果有两个线程 x 和 y ，如果 x 初次从内存中读取变量值为 A；线程 y 对它进行了一些操作使其变成 B，然后再改回 A，那么线程 x 进行 CAS 的时候就会误认为这个值没有被修改过。尽管 CAS 操作会成功执行，但是不代表它是没有问题的，如果有一个单向链表 A B 组成的栈，栈顶为 A，线程 T1 准备执行 CAS 操作 head.compareAndSet(A,B)，在执行之前线程 T2 介入，T2 将A、B出栈，然后又把C、A放入栈，T2执行完毕；切回线程 T1，T1 发现栈顶元素依然为 A，也会成功执行 CAS 将栈顶元素修改为 B，但因为 B.next 为 null，最终栈中意外地丢失了 C 元素。（引用自[JUC源码分析—CAS和Unsafe](https://www.jianshu.com/p/a897c4b8929f)）

对于 CAS 的解决方案是版本号管理。为每一个变量保存一个版本号，当这个值由 A 变为 B，然后又变成 A 时，版本号会不同。

> 从 Java 1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决ABA问题。这个类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**循环时间长，开销变大**

自旋 CAS 如果长时间不成功，会给 CPU 带来较大的执行开销。

**只能保证一个变量的原子操作**

可以将两个变量合并成一个变量（使用单个变量的二进制高位低位分别表示不同的变量），然后用 CAS 操作。

> AQS 框架借助两个类：Unsafe(提供CAS操作) 和 LockSupport(提供park/unpark操作)。Unsafe 提供的 API 包括内存操作、CAS、Class 相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等。

### 参考

[JUC源码分析—CAS和Unsafe](https://www.jianshu.com/p/a897c4b8929f)

[JAVA CAS原理深度分析](https://www.cnblogs.com/kisty/p/5408264.html)