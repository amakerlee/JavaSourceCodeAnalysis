顶部注释：
底层：HashMap是Map接口基于哈希表的实现。
是否允许null：HashMap允许key和value为null。
是否有序：HashMap不保证映射的顺序，特别是它不保证该顺序恒久不变。
何时rehash：超出当前允许的最大容量。initial capacity*load factor就是当前允许的最大元素数目，超过initial capacity*load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍。
初始化容量对性能的影响：不应设置地太小，设置地小虽然可以节省空间，但会频繁地进行rehash操作。rehash会影响性能。总结：小了会增大时间开销（频繁rehash）；大了会增大空间开销（占用了更多空间）和时间开销（影响遍历）。
加载因子对性能的影响：加载因子过高虽然减少了空间开销，但同时也增加了查询成本。0.75是个折中的选择。总结：小了会增大时间开销（频繁rehash）；大了会也增大时间开销（影响遍历）。
是否同步：HashMap不是同步的。
迭代器：迭代器是fast-fail的。


putVal:
1. 如果哈希表为空，调用resize()创建一个哈希表。
2. 如果指定参数hash在表中没有对应的桶，即为没有碰撞，直接将键值对插入到哈希表中即可。
3. 如果有碰撞，遍历桶，找到key映射的节点
    3.1 桶中的第一个节点就匹配了，将桶中的第一个节点记录起来。
    3.2 如果桶中的第一个节点没有匹配，且桶中结构为红黑树，则调用红黑树对应的方法插入键值对。
    3.3 如果不是红黑树，那么就肯定是链表。遍历链表，如果找到了key映射的节点，就记录这个节点，退出循环。如果没有找到，在链表尾部插入节点。插入后，如果链的长度大于TREEIFY_THRESHOLD这个临界值，则使用treeifyBin方法把链表转为红黑树。
4. 如果找到了key映射的节点，且节点不为null
    4.1 记录节点的vlaue。
    4.2 如果参数onlyIfAbsent为false，或者oldValue为null，替换value，否则不替换。
    4.3 返回记录下来的节点的value。
5. 如果没有找到key映射的节点（2、3步中讲了，这种情况会插入到hashMap中），插入节点后size会加1，这时要检查size是否大于临界值threshold，如果大于会使用resize方法进行扩容。